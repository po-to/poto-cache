<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>@po-to/pt-cache</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">@po-to/pt-cache</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> @po-to/pt-cache</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="pt-cache">pt-cache</h1>
				<p>a shim library for operate browser storage</p>
				<ul>
					<li>项目主页：<a href="http://po-to.org/pt-cache">po-to.org/pt-cache</a></li>
					<li>项目地址：<a href="https://github.com/po-to/pt-cache">Github</a></li>
					<li>API文档： <a href="http://po-to.org/pt-cache/docs">在线文档</a> 或见 /docs</li>
					<li>案例应用：<a href="http://po-to.org/pt-cache/examples">在线文档</a> 或见 /examples</li>
					<li>概述简介</li>
					<li>使用说明</li>
				</ul>
				<blockquote>
					<p>为方便描述说明，以下可能会使用typescript或es6的糖衣语法，实际使用本库时并不要求使用typescript或es6</p>
				</blockquote>
				<h1 id="-">简介</h1>
				<p> 关于网页的cache，我们知道HTTP协议中处理缓存的机制一般有：Expires、Last-Modified、Etag等，由浏览器实现并封装，不可以编程方式访问。<br> H5提供由manifest指定的AppCache,可对站点文件的离线存储进行简单配制，使用场景很有限。<br> 在实际开发中，我们经常需要可编程控制的数据级cache，基于H5为我们提供了<em>sessionStorage</em>和<em>localStorage</em>，在此之上进行抽象与封装，因此产生了此框架。</p>
				<h2 id="-">更广泛的概念</h2>
				<p> 我们假定缓存除了创建时设定的有效条件和周期，还存在不同类别的生命周期：</p>
				<ul>
					<li>memoryStorage -- 存于内存中，即JS变量，刷新页面将消失</li>
					<li>sessionStorage -- 存于浏览器sessionStorage中，关闭浏览器将消失</li>
					<li>localStorage -- 存在于浏览品localStorage中，可认为长久存在</li>
				</ul>
				<p>浏览器原生为我们维护了三种不同生命周期的cache，但是却不能在此基础上与缓存自身的周期设定取并集，以此来满足我们在实际开发中某些应用场景。比如：</p>
				<blockquote>
					<p><em>最新列表</em>，需求希望页面刷新时拉取一次，其后每1小时自动拉取一次，而且点击“<em>立即更新</em>”的按钮，能立即拉取。</p>
				</blockquote>
				<ul>
					<li>如果使用http缓存：<ol>
							<li>最新列表不一定是一个独立的API接口。</li>
							<li>设定有效期为1小时，但是无法做到页面刷新或点击“<em>立即更新</em>”按钮时立即更新。</li>
						</ol>
					</li>
					<li>我们不得不用<em>setInterval</em>方法：<ol>
							<li>针对这个具体需求，需要具体的编程</li>
							<li>如果某一天需求变更为半小时拉取一次，我们又不得不翻出这段JS来更改</li>
						</ol>
					</li>
					<li><p>如果使用pt-cache：</p>
						<pre><code>  <span class="hljs-keyword">var</span> ptcache = <span class="hljs-built_in">require</span>(<span class="hljs-string">"po-to/pt-cache"</span>);

  <span class="hljs-comment">/* 假设我们有一个取数据的api接口，url是"xxx" */</span>
  <span class="hljs-keyword">var</span> url = <span class="hljs-string">"xxx"</span>;

  <span class="hljs-comment">/* 每1秒拉取1次数据 */</span>
  setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      ptcache.load({<span class="hljs-attr">url</span>:url}).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>{
          <span class="hljs-comment">//对比data并更新dom</span>
      });
  },<span class="hljs-number">1000</span>)

  <span class="hljs-comment">/* 点击“*立即更新*”按钮，删除该笔缓存即可 */</span>
  $(<span class="hljs-string">"#btn-update"</span>).on(<span class="hljs-string">"click"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
      ptcache.removeItem(url);
  })

  <span class="hljs-comment">/* 此时，api可输出一个自定义的http响应头X-Cache=r3600s，r表示该api输出的数据将缓存放入内存，3600s表示缓存1小时 */</span>
</code></pre><p>  这样一来：JS虽然每1秒会去拉取一次数据，但因为我们设定了X-Cache=r3600s的自定义http头，所以在1小时内，JS拉取的只是缓存在内存中的数据。对于前端来说，用一个通用的前后端协议即可简化并节省针对特定业务的编程。而且对于某些<strong>高频的适时刷新</strong>，访问内存或sessionStorage，远比访问浏览器XMLHttpRequest并命中http协议的cache要高性能得多</p>
					</li>
				</ul>
				<h2 id="-">除此之外</h2>
				<p>浏览器原生的memoryStorage、sessionStorage、localStorage不提供缓存命中、失效、回收、溢出、加密机制，本库扩展了以上功能</p>
				<h1 id="-">使用说明</h1>
				<h2 id="-">兼容性与扩展性</h2>
				<p>兼容所有支持sessionStorage、localStorage的浏览器，如IE8<br>除localStorage外，如果需要可扩展至websql等本地数据库</p>
				<h2 id="-">安装</h2>
				<blockquote>
					<p>npm install @po-to/pt-cache --save-dev</p>
					<p>define([ &quot;@po-to/pt-cache&quot; ],function( ptcache ){ ... });</p>
				</blockquote>
				<h2 id="-">目录结构</h2>
				<blockquote>
					<p>源文件：./src， 案例：./examples， 文档：./docs</p>
				</blockquote>
				<h2 id="-">编译</h2>
				<blockquote>
					<p>npm start</p>
				</blockquote>
				<h2 id="-">运行案例</h2>
				<blockquote>
					<p>npm run examples</p>
				</blockquote>
				<h2 id="-">依赖</h2>
				<ul>
					<li><p>本库并不限制自定义缓存头的具体实现，如借用http协议自定义头X-Cache等，仅提供接口：</p>
						<pre><code>  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRequestResult</span> {</span>
      cache?: { type?: CacheType, expired?: string, version?: string, encryption?: <span class="hljs-keyword">boolean</span> },
      notModified?: <span class="hljs-keyword">boolean</span>,
<span class="hljs-symbol">      dataType:</span> string,
<span class="hljs-symbol">      data:</span> any
  }
</code></pre></li>
					<li><p>本库并不提供外部请求的具体实现，如ajax等，仅提供接口：</p>
						<pre><code>  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRequestOptions</span> {</span>
<span class="hljs-symbol">      url:</span> string;
      method?: string;
      data?:{[<span class="hljs-string">key:</span>string]:any};
      render?(data:any):any;
<span class="hljs-symbol">      headers:</span>{[<span class="hljs-string">key:</span>string]:any};
      version?: string;
      timeout?: number;
  }

  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRequest</span>{</span>
      (<span class="hljs-string">request:</span> IRequestOptions,<span class="hljs-string">success:</span>(<span class="hljs-string">data:</span>IRequestResult)=&gt;<span class="hljs-keyword">void</span>,<span class="hljs-string">fail:</span>(<span class="hljs-string">error:</span>Error)=&gt;<span class="hljs-keyword">void</span>) : <span class="hljs-keyword">void</span>;
  }

  <span class="hljs-comment">//用户可自由引入第三方库，如jquery的$.ajax来封装实现以上接口，假设requestFunction就是你实现IRequest接口的外部请求方法，</span>
  <span class="hljs-comment">//调用：ptcache.setConfig({request:requestFunction})来配置使用</span>
</code></pre></li>
				</ul>
				<ul>
					<li><p>本库并不提供对缓存写入的字符加密解密的具体实现，仅提供接口：</p>
						<pre><code>  interface IEncryption {
      encrypt: (<span class="hljs-built_in">value</span>: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>;
      decrypt: (code: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>;
  }
  <span class="hljs-comment">//用户可自由引入第三方库，如：goolge的CryptoJS.AES，假设myEncryption就是你实现IEncryption接口的方法</span>
  /*
      ptcache.setConfig(encryption:{
          encode : function(str){
              <span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> = 'dsfsdfsdfe';<span class="hljs-comment">//key可由服务端生成</span>
              <span class="hljs-built_in">var</span> iv = <span class="hljs-built_in">key</span>.substr(<span class="hljs-number">0</span>,<span class="hljs-number">16</span>);
              <span class="hljs-built_in">key</span> = CryptoJS.enc.Utf8.<span class="hljs-built_in">parse</span>(<span class="hljs-built_in">key</span>);
              iv = CryptoJS.enc.Utf8.<span class="hljs-built_in">parse</span>(iv);
              str = CryptoJS.AES.encrypt(str,<span class="hljs-built_in">key</span>,{iv:iv,padding:CryptoJS.pad.ZeroPadding});
              return str.ciphertext.toString(CryptoJS.enc.Base64);
          },
          decode : function(str){
              <span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> = 'dsfsdfsdfe';<span class="hljs-comment">//key可由服务端生成</span>
              <span class="hljs-built_in">var</span> iv = <span class="hljs-built_in">key</span>.substr(<span class="hljs-number">0</span>,<span class="hljs-number">16</span>);
              <span class="hljs-built_in">key</span> = CryptoJS.enc.Utf8.<span class="hljs-built_in">parse</span>(<span class="hljs-built_in">key</span>);
              iv = CryptoJS.enc.Utf8.<span class="hljs-built_in">parse</span>(iv);
              str = CryptoJS.AES.decrypt(str,<span class="hljs-built_in">key</span>,{iv:iv,padding:CryptoJS.pad.ZeroPadding});
              return CryptoJS.enc.Utf8.stringify(str);
          }
      })
  */
</code></pre></li>
					<li><p>本库仅提供一种序列化对象进行存储的序列化器：json，如果你需要别的序列化器，请实现接口：</p>
						<pre><code>  interface ISerialization {
      decode: (str: <span class="hljs-keyword">string</span>) =&gt; any;
      encode: (data: any) =&gt; <span class="hljs-keyword">string</span>;
  }
  /*
  比如，你想在缓存中存入xml对象，请调用：ptcache.setConfig({
      serializations:{
          <span class="hljs-keyword">xml</span> <span class="hljs-title">: {
              decode</span>: (str: <span class="hljs-keyword">string</span>) =&gt; <span class="hljs-keyword">xml</span> <span class="hljs-title">//具体请自行实现
              encode</span>: (data: xml) =&gt; <span class="hljs-keyword">string</span> //具体请自行实现
          }
      }
  })
  */
</code></pre></li>
					<li><p>由于本库提供load()方法集成代理外部请求，调用此方法前，可设置异步计数器ITaskCounter来实现异步请求计数，从而实现如全局loading等效果。发起一个异步请求：计数器+1；完成一个异步请求：计数器-1；<br>本库不直接提供计数器，仅提供接口ITaskCounter，调用load方法发起异步请求时，如果有设置TaskCounter，则会触发ITaskCounter.addItem方法，将异步清求的promise传入计数器</p>
						<pre><code>  <span class="hljs-comment">/**
   * 如果要实现异步请求计数，请设置实现该接口的TaskCounter´.
   * <span class="hljs-doctag">@param</span> promise 异步请求返回的Promise对象
   * <span class="hljs-doctag">@param</span> note 异步请求的注解
   */</span>
  addItem(<span class="hljs-string">promise:</span>Promise&lt;any&gt;,note?:string):<span class="hljs-keyword">void</span>;
  <span class="hljs-comment">/*
  比如，你如果使用@po-to/tomato库，可直接调用：ptcache.setConfig({
      taskCounter: tomato.taskCounter
  })
  */</span>
</code></pre></li>
				</ul>
				<h2 id="api-">API说明</h2>
				<h3 id="-cache">写入一笔cache</h3>
				<blockquote>
					<p>如：ptcache.setItem(&quot;list&quot;,new ptcache.CacheContent([...]))</p>
				</blockquote>
				<pre><code>/*
@param <span class="hljs-symbol">key:</span>string 为cache的key
@param <span class="hljs-symbol">content:</span> CacheContent 为cache的值，稍后会详细说明
@param <span class="hljs-symbol">type?:</span> CacheType 为cache类型，取值为<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span> ，默认为<span class="hljs-number">0</span>，即内存型
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">CacheType</span> {</span>
        Ram = <span class="hljs-number">0</span>, 内存型
        Session = <span class="hljs-number">1</span>, <span class="hljs-regexp">//</span>会话型
        Local = <span class="hljs-number">2</span>, <span class="hljs-regexp">//</span>持久型
    }
@<span class="hljs-keyword">return</span> boolean 是否创建成功
*<span class="hljs-regexp">/
function setItem(key: string, content: CacheContent, type?: CacheType): boolean;</span>
</code></pre><p>ptcache.CacheContent是本库的一个类，写入缓存的数据必须用这个类包装：</p>
				<pre><code><span class="hljs-keyword">class</span> CacheContent {
    /*
    @param data?: any 为要写入cache的值，如果data为<span class="hljs-literal">null</span>或是undefined，表示不写入data，即表示更新某cache
    @param dataType?: <span class="hljs-built_in">string</span> 为data值的类型，由于sessionStorage和localStorage只能存储文本，当data值不为文本时，本库将根据此dataType来序列化和反序列化，此默认值为<span class="hljs-string">"json"</span>
    @param expired?: <span class="hljs-built_in">string</span> 为cache的过期时间
        如果expired为一个数字描述，代表相对时间：
            expired &gt; <span class="hljs-number">0</span> 表示expired秒之后过期
            expired = <span class="hljs-number">0</span> 表示立即过期，等于写入缓存无效
            expired &lt; <span class="hljs-number">0</span> 表示永不过期，除非缓存类型大生命周期结束
        如果expired为一个标准的日期描述，即可以用JS内置的<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>(expired)转化为时间，则表示到了expired时间后过期
    @param version?: <span class="hljs-built_in">string</span> 为需要的版本验证，类似于http协议中的ETag。
        如果一笔cache在有效期内，将直接命中并返回该笔cache
        如果一笔cache已经失效：
            如果这笔cache无version描述，则表示命中失败，取出来的cache为<span class="hljs-literal">null</span>
            如果这笔cache有version描述，则表示该笔cache需要重新通过版本进行验证，验证结果有可能是<span class="hljs-keyword">not</span> modified或是失效
    @param encryption?: boolean 是否需要加密存储，如果为<span class="hljs-literal">true</span>，本库将调用Encryption.encrypt()或decrypt()方法加、解密之后再储存。
        本库不直接提供加解密的实现，但提供接口：
        interface IEncryption {
            encrypt: (value: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>;
            decrypt: (code: <span class="hljs-built_in">string</span>) =&gt; <span class="hljs-built_in">string</span>;
        }
        用户可自行引用第三方加解密库，如：google的CryptoJS，使用案例中有演示。
        使用此参数前，用户需要先调用setConfig({encryption:myEncryption})设置加解密方法
    */
    constructor(data?: any, dataType?: <span class="hljs-built_in">string</span>, expired?: <span class="hljs-built_in">string</span>, version?: <span class="hljs-built_in">string</span>, encryption?: boolean);
}
</code></pre><h3 id="-cache">读取一笔cache</h3>
				<blockquote>
					<p>如：var result = ptcache.getItem(&quot;list&quot;);</p>
				</blockquote>
				<pre><code>/*
@param <span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span> 要获取的缓存<span class="hljs-built_in">key</span>
@param <span class="hljs-built_in">type</span>?: CacheType 要从何种缓存池中获取，通常可不传，本库将按memoryStorage &gt; sessionStorage &gt; localStorage依次查找
@return CacheResult | <span class="hljs-built_in">null</span> 返回为<span class="hljs-built_in">null</span>表示未命中缓存，返回为CacheResult解释如下：
    class CacheResult {
        readonly <span class="hljs-built_in">value</span>: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//cache序列化后的原始值，为字符串</span>
        readonly version: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//该cache的版本描述</span>
        readonly <span class="hljs-keyword">from</span>: CacheType; <span class="hljs-comment">//该cache来自于哪个类型，参见CacheType</span>
        toData(): <span class="hljs-built_in">any</span>; <span class="hljs-comment">//取出最终的cache值</span>
    }
    从此可看出，getItem取出的cache并不是最终的缓存值，而是经过包装的CacheResult实例对象，调用此对象的toData()方法，才可以得到最终值。
    如果CacheResult实例对象的version属性为空，表示该cache是有效的；反之，表示虽然命中的cache，但还不一定是最终有效，需要根据此version值确认
*/
function getItem(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">type</span>?: CacheType): CacheResult | <span class="hljs-built_in">null</span>;
</code></pre><h3 id="-cache">更新一笔cache</h3>
				<blockquote>
					<p>如：ptcache.setItem(&quot;list&quot;,new ptcache.CacheContent(null,null,100))</p>
				</blockquote>
				<p>本库不直接提供更新一笔cache的方法，用户可直接调用setItem重设即可；
					如果需要更新的仅仅是过期时间或是版本标识，不需要更新内容，在调用setItem方法的时候，new ptcache.CacheContent(data,dataType,expired,version,encryption),其中data,dataType传入null值即可；
				如 ptcache.setItem(&quot;list&quot;,new ptcache.CacheContent(null,null,100))，就表示将key为&quot;list&quot;的这笔cache往后增加100秒有效期</p>
				<h3 id="-cache">删除一笔cache</h3>
				<blockquote>
					<p>如：ptcache.removeItem(&quot;list&quot;);</p>
				</blockquote>
				<pre><code>/*
    @param <span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span> 要删除的缓存<span class="hljs-built_in">key</span>
    @param <span class="hljs-built_in">type</span>?: CacheType 要从何种缓存池中删除，通常可不传，本库将按memoryStorage &gt; sessionStorage &gt; localStorage依次查找
*/
function removeItem(<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>, <span class="hljs-built_in">type</span>?: CacheType): void;
</code></pre><h3 id="-cache">清空所有cache</h3>
				<blockquote>
					<p>如：ptcache.clear(1);</p>
				</blockquote>
				<pre><code><span class="hljs-comment">/*
    @param type?: CacheType 要清空何种缓存池，不传为清空所有三种缓存
*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clear</span><span class="hljs-params">(type?: CacheType)</span>: void</span>;
</code></pre><h3 id="-">与外部请求相结合</h3>
				<blockquote>
					<p>如：ptcache.load({url:&quot;xxx&quot;}).then(function(data){...});</p>
				</blockquote>
				<pre><code>/*
    @param requestOptions: IRequestOptions 发起外部请求的数据，该数据将传入第三方外部请求实现API:IRequest，进行外部请求
        interface IRequestOptions {
            url: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//请求地址</span>
            method?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//方法，如"get","post","put","delete"</span>
            data?: { <span class="hljs-comment">//请求参数</span>
                [<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
            };
            render?(data: <span class="hljs-built_in">any</span>): <span class="hljs-built_in">any</span>; <span class="hljs-comment">//对请求结果加工</span>
            headers: { <span class="hljs-comment">//请求头设置</span>
                [<span class="hljs-built_in">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>;
            };
            version?: <span class="hljs-built_in">string</span>; <span class="hljs-comment">//版本验证</span>
            timeout?: number; <span class="hljs-comment">//外部请求的超时时间</span>
            note?:<span class="hljs-built_in">string</span>; <span class="hljs-comment">//加载信息说明</span>
            hideLoading?:boolean; <span class="hljs-comment">//如果设置了taskCounter，该参数控制是否将该请求加入异步计数器</span>
        }
    @param succss?: (data: <span class="hljs-built_in">any</span>) =&gt; void 请求成功回调
    @param fail?: (error: Error) =&gt; void) 请求失败回调
    @return  Promise&lt;<span class="hljs-built_in">any</span>&gt;
*/
function <span class="hljs-built_in">load</span>(requestOptions: IRequestOptions, succss?: (data: <span class="hljs-built_in">any</span>) =&gt; void, fail?: (error: Error) =&gt; void): Promise&lt;<span class="hljs-built_in">any</span>&gt;;
</code></pre><p>注意：ptcache.load方法封装了ptcache.getItem方法，在发起外部请求之前，会查询缓存中是否存在以url为key的缓存，如果存在，则进一步验证version的有效性。如果验证有效，则不发起真实的外部请求，而返回cache值
				所以回调函数中接受的data: any，是最终的值，而非CacheResult实例对象。</p>
				<p>外部请求，可由server端输出一个自定义的responseHeader X-Cache,值为&quot;1,3600,Wed Dec 21 2016 17:25:57&quot;，表示要将该数据放入sessionStorage中缓存，缓存有效期是3600秒，版本识别号为Wed Dec 21 2016 17:25:57，缓存到期后将version:Wed Dec 21 2016 17:25:57发送回server进行验证，如果无需更新，server可返回304,(Not Modified),并重新给该缓存增加有效期</p>
				<h3 id="config-">config配置</h3>
				<blockquote>
					<p>如：ptcache.setConfig({namespace:&quot;$#@&quot;}})</p>
				</blockquote>
				<pre><code>function setConfig(<span class="hljs-string">options:</span> {
    namespace?: string; <span class="hljs-comment">//在存入sessionStorage或是localStorage时，每一笔cache都会以此namespace为前缀，避免冲突</span>
    ramStorageLimit?: number <span class="hljs-comment">//内存型缓存最大占用内存空间，默认为0，表示无限制</span>
    encryption?: IEncryption; <span class="hljs-comment">// 加解密方法，由第三方库提供</span>
    mappingKey?: (<span class="hljs-string">key:</span> string) =&gt; string; <span class="hljs-comment">//每笔cache的key，可以经过此方法映射，比如以url为key进行写入会太长，可将url进行md5之后再作为key写入</span>
    <span class="hljs-comment">/* 
    由于sessionStorage或是localStorage只能储存文本，所以存入数据非文本时，将跟据dataType来调用此序列化方法进行序列化与反序列化
    interface ISerialization {
        decode: (str: string) =&gt; any;
        encode: (data: any) =&gt; string;
    }
    本库默认提供一种ISerialization，名字为"json"
    */</span>
    serializations?: { 
<span class="hljs-symbol">        string:</span> ISerialization;
    };
    <span class="hljs-comment">//外部请求的方法，由第三方库提供</span>
    request?: IRequest
}): <span class="hljs-keyword">void</span>;
</code></pre><h3 id="-">缓存空间的回收与溢出处理</h3>
				<blockquote>
					<p>内部自动执行</p>
				</blockquote>
				<p>设置一笔缓存时，sessionStorage和localStorage在写满溢出时会抛出一个错误，本库会捕获这个错误，之后会采取回收策略<br>memoryStorage不会产生溢出错误，可自行设置一个存储上限值（本库会将所有写入memoryStorage的每笔cache的key，value长度求和，作为占用空间值），超过这个值后，本库会采取回收策略。<br>用户可以通过setConfig({ramStorageLimit: 1024*20})来设置此值，由于js无法真正管理内存，所以此值单位为字符个数，并不精准<br>回收策略为：</p>
				<ul>
					<li>先将缓存池中所有失效的缓存清除，如果依然不够存储空间</li>
					<li>将缓存池中所有缓存按<strong>访问时间</strong>排序，回收较久没访问的冷门数据</li>
				</ul>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-external-module">
						<a href="modules/_pt_cache_.html">"pt-<wbr>cache"</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.org/" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>